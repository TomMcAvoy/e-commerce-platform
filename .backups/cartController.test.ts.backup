import request from 'supertest';
import app from '../../index';
import User from '../../models/User';
import Product from '../../models/Product';
import Cart from '../../models/Cart';
import mongoose from 'mongoose';
import jwt from 'jsonwebtoken';
import { IProduct, IProductDocument } from '../../models/Product';
import { IUser } from '../../models/User';
import { ICart } from "../../models/Cart";
// Helper to generate a valid JWT for a user
const generateToken = (userId: mongoose.Types.ObjectId) => {
  return jwt.sign({ id: userId }, process.env.JWT_SECRET as string, { expiresIn: '1h' });
};

describe('Cart API', () => {
  let user: IUser;
  let token: string;
  let product1: IProduct;
  let product2: IProduct;
  let categoryId: mongoose.Types.ObjectId;
  let vendorId: mongoose.Types.ObjectId;
  const guestSessionId = new mongoose.Types.ObjectId().toString();

  beforeAll(async () => {
    // Create dummy category and vendor for product creation
    categoryId = new mongoose.Types.ObjectId();
    vendorId = new mongoose.Types.ObjectId();
  });

 beforeEach(async () => {
  // Clear collections before each test
  await User.deleteMany({});
  await Product.deleteMany({});
  await Cart.deleteMany({}); 

    user = await User.create({
      name: 'Test User',
      email: 'test@example.com',
      password: '123456',
      role: 'user'
    }) as IUserDocument;

    token = generateToken((user as IUserDocument)._id);

    product1 = await Product.create({
      name: 'Product 1',
      description: 'Description 1',
      price: 10,
      category: 'Category 1',
      vendor: (user as IUserDocument)._id,
      stock: 100
    }) as IProductDocument;

    product2 = await Product.create({
      name: 'Product 2',
      description: 'Description 2',
      price: 20,
      category: 'Category 2',
      vendor: (user as IUserDocument)._id,
      stock: 50
    }) as IProductDocument;
  });

  describe('POST /api/cart/add', () => {
    it('should add item to cart', async () => {
      const res = await request(app)
        .post('/api/cart/add')
        .set('Authorization', `Bearer ${token}`)
        .send({ productId: (product1 as IProductDocument)._id.toString(), quantity: 2 });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(1);
      expect(res.body.data.items[0].quantity).toBe(2);
    });
  });

  describe('GET /api/cart', () => {
    it('should get user cart', async () => {
      // Create a cart first
      const cart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });
      const itemId = cart.items[0]._id;

      const res = await request(app)
        .get('/api/cart')
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(1);
    });
  });

  describe('PUT /api/cart/update/:itemId', () => {
    it('should update cart item quantity', async () => {
      const cart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });
      const itemId = cart.items[0]._id;

      const res = await request(app)
        .put(`/api/cart/update/${itemId}`)
        .set('Authorization', `Bearer ${token}`)
        .send({ quantity: 3 });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
    });
  });

  describe('DELETE /api/cart/remove/:itemId', () => {
    it('should remove item from cart', async () => {
      const cart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const res = await request(app)
        .delete('/api/cart/clear')
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
    });
  });

  describe('POST /api/cart/add - integration', () => {
    it('should handle adding multiple items', async () => {
      // Add first item
      await request(app)
        .post('/api/cart/add')
        .set('Authorization', `Bearer ${token}`)
        .send({ productId: (product1 as IProductDocument)._id.toString(), quantity: 1 });

      expect(true).toBe(true); // Basic assertion since we're testing integration
    });
  });

  describe('Cart operations', () => {
    it('should handle cart operations correctly', async () => {
      // Create cart with items
      const cart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 2, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      // Create another cart for different user
      const otherUser = await User.create({
        name: 'Other User',
        email: 'other@example.com',
        password: '123456',
        role: 'user'
      });

      const otherCart = await Cart.create({
        userId: (otherUser as IUserDocument)._id,
        items: [{ productId: (product2 as IProductDocument)._id, quantity: 1, price: 20, name: 'Product 2', sku: 'P2' }]
      });

      expect(cart.items).toHaveLength(1);
      expect(otherCart.items).toHaveLength(1);
    });

    it('should handle cart updates correctly', async () => {
      const cart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 2, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      // Update the cart
      await Cart.findByIdAndUpdate(cart._id, {
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const updatedCart = await Cart.findById(cart._id);
      expect(updatedCart).toBeTruthy();
    });
  describe('POST /api/cart/items (addToCart)', () => {
    it('should add item with variant to cart', async () => {
      // First create a product with variants
      const productWithVariants = await Product.create({
        name: 'Variable Product',
        description: 'Product with variants',
        price: 25,
        category: 'Variable Category',
        vendor: (user as IUserDocument)._id,
        stock: 100,
        variants: [
          { _id: new mongoose.Types.ObjectId(), value: 'Size M', price: 25, sku: 'VAR-M', stock: 50 },
          { _id: new mongoose.Types.ObjectId(), value: 'Size L', price: 30, sku: 'VAR-L', stock: 30 }
        ]
      });

      const variantId = productWithVariants.variants[0]._id;

      const res = await request(app)
        .post('/api/cart/items')
        .set('Authorization', `Bearer ${token}`)
        .send({ 
          productId: productWithVariants._id.toString(), 
          variantId: variantId?.toString(),
          quantity: 2 
        });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(1);
      expect(res.body.data.items[0].variantId).toBe(variantId?.toString());
      expect(res.body.data.items[0].name).toBe('Variable Product - Size M');
      expect(res.body.data.items[0].price).toBe(25);
    });

    it('should reject adding archived product to cart', async () => {
      // Create archived product
      const archivedProduct = await Product.create({
        name: 'Archived Product',
        description: 'This product is archived',
        price: 15,
        category: 'Archive Category',
        vendor: (user as IUserDocument)._id,
        stock: 0,
        isArchived: true
      });

      const res = await request(app)
        .post('/api/cart/items')
        .set('Authorization', `Bearer ${token}`)
        .send({ productId: archivedProduct._id.toString(), quantity: 1 });

      expect(res.status).toBe(400);
      expect(res.body.success).toBe(false);
      expect(res.body.message).toBe('Product is not available');
    });

    it('should reject invalid quantity', async () => {
      const res = await request(app)
        .post('/api/cart/items')
        .set('Authorization', `Bearer ${token}`)
        .send({ productId: (product1 as IProductDocument)._id.toString(), quantity: 0 });

      expect(res.status).toBe(400);
      expect(res.body.success).toBe(false);
      expect(res.body.message).toBe('Quantity must be at least 1');
    });

    it('should reject non-existent variant', async () => {
      const nonExistentVariantId = new mongoose.Types.ObjectId();

      const res = await request(app)
        .post('/api/cart/items')
        .set('Authorization', `Bearer ${token}`)
        .send({ 
          productId: (product1 as IProductDocument)._id.toString(), 
          variantId: nonExistentVariantId.toString(),
          quantity: 1 
        });

      expect(res.status).toBe(404);
      expect(res.body.success).toBe(false);
      expect(res.body.message).toBe('Product variant not found');
    });

    it('should add item to guest cart with session ID', async () => {
      const res = await request(app)
        .post('/api/cart/items')
        .set('x-session-id', guestSessionId)
        .send({ productId: (product1 as IProductDocument)._id.toString(), quantity: 1 });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(1);
      expect(res.body.message).toBe('Item added to cart');

      // Verify guest cart was created
      const guestCart = await Cart.findOne({ sessionId: guestSessionId });
      expect(guestCart).toBeTruthy();
      expect(guestCart?.items).toHaveLength(1);
    });

    it('should increment quantity for existing item', async () => {
      // Add item first time
      await request(app)
        .post('/api/cart/items')
        .set('Authorization', `Bearer ${token}`)
        .send({ productId: (product1 as IProductDocument)._id.toString(), quantity: 2 });

      // Add same item again
      const res = await request(app)
        .post('/api/cart/items')
        .set('Authorization', `Bearer ${token}`)
        .send({ productId: (product1 as IProductDocument)._id.toString(), quantity: 3 });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(1);
      expect(res.body.data.items[0].quantity).toBe(5); // 2 + 3
    });
  });

  describe('PUT /api/cart/items/:itemId (updateCartItem)', () => {
    it('should remove item when quantity is set to 0', async () => {
      const cart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [
          { productId: (product1 as IProductDocument)._id, quantity: 2, price: 10, name: 'Product 1', sku: 'P1' },
          { productId: (product2 as IProductDocument)._id, quantity: 1, price: 20, name: 'Product 2', sku: 'P2' }
        ]
      });

      const itemId = cart.items[0]._id;

      const res = await request(app)
        .put(`/api/cart/items/${itemId}`)
        .set('Authorization', `Bearer ${token}`)
        .send({ quantity: 0 });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(1); // One item removed
      expect(res.body.message).toBe('Item removed from cart');
    });

    it('should reject invalid quantity types', async () => {
      const cart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const itemId = cart.items[0]._id;

      const res = await request(app)
        .put(`/api/cart/items/${itemId}`)
        .set('Authorization', `Bearer ${token}`)
        .send({ quantity: 'invalid' });

      expect(res.status).toBe(400);
      expect(res.body.success).toBe(false);
      expect(res.body.message).toBe('Valid quantity is required');
    });

    it('should handle non-existent item update', async () => {
      const nonExistentItemId = new mongoose.Types.ObjectId();

      const res = await request(app)
        .put(`/api/cart/items/${nonExistentItemId}`)
        .set('Authorization', `Bearer ${token}`)
        .send({ quantity: 5 });

      expect(res.status).toBe(404);
      expect(res.body.success).toBe(false);
      expect(res.body.message).toBe('Cart not found');
    });

    it('should update guest cart item with session ID', async () => {
      const cart = await Cart.create({
        sessionId: guestSessionId,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const itemId = cart.items[0]._id;

      const res = await request(app)
        .put(`/api/cart/items/${itemId}`)
        .set('x-session-id', guestSessionId)
        .send({ quantity: 4 });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items[0].quantity).toBe(4);
      expect(res.body.message).toBe('Cart item updated');
    });
  });

  describe('DELETE /api/cart/items/:itemId (removeFromCart)', () => {
    it('should remove specific item from cart', async () => {
      const cart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [
          { productId: (product1 as IProductDocument)._id, quantity: 2, price: 10, name: 'Product 1', sku: 'P1' },
          { productId: (product2 as IProductDocument)._id, quantity: 1, price: 20, name: 'Product 2', sku: 'P2' }
        ]
      });

      const itemIdToRemove = cart.items[0]._id;

      const res = await request(app)
        .delete(`/api/cart/items/${itemIdToRemove}`)
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(1);
      expect(res.body.data.items[0].name).toBe('Product 2');
      expect(res.body.message).toBe('Item removed from cart');
    });

    it('should handle removing non-existent item', async () => {
      await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const nonExistentItemId = new mongoose.Types.ObjectId();

      const res = await request(app)
        .delete(`/api/cart/items/${nonExistentItemId}`)
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(404);
      expect(res.body.success).toBe(false);
      expect(res.body.message).toBe('Cart item not found');
    });

    it('should remove item from guest cart', async () => {
      const cart = await Cart.create({
        sessionId: guestSessionId,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const itemId = cart.items[0]._id;

      const res = await request(app)
        .delete(`/api/cart/items/${itemId}`)
        .set('x-session-id', guestSessionId);

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(0);
      expect(res.body.message).toBe('Item removed from cart');
    });
  });

  describe('GET /api/cart (getCart)', () => {
    it('should return empty cart for new user', async () => {
      const res = await request(app)
        .get('/api/cart')
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(0);
      expect(res.body.data.subtotal).toBe(0);
      expect(res.body.data.itemCount).toBe(0);
    });

    it('should return empty cart for guest without session ID', async () => {
      const res = await request(app)
        .get('/api/cart');

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(0);
      expect(res.body.data.subtotal).toBe(0);
      expect(res.body.data.itemCount).toBe(0);
    });

    it('should get guest cart with session ID in query parameter', async () => {
      await Cart.create({
        sessionId: guestSessionId,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 2, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const res = await request(app)
        .get(`/api/cart?sessionId=${guestSessionId}`);

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(1);
      expect(res.body.data.itemCount).toBe(2);
    });

    it('should populate product details in cart items', async () => {
      await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const res = await request(app)
        .get('/api/cart')
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items[0]).toHaveProperty('productId');
      expect(res.body.data.items[0].productId).toHaveProperty('name');
    });
  });

  describe('POST /api/cart/merge (mergeCart)', () => {
    it('should merge guest cart with user cart on login', async () => {
      // Create user cart
      await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      // Create guest cart
      const guestCart = await Cart.create({
        sessionId: guestSessionId,
        items: [
          { productId: (product2 as IProductDocument)._id, quantity: 2, price: 20, name: 'Product 2', sku: 'P2' }
        ]
      });

      const res = await request(app)
        .post('/api/cart/merge')
        .set('Authorization', `Bearer ${token}`)
        .send({ guestSessionId });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(2); // Both items merged
      expect(res.body.message).toBe('Cart merged successfully');

      // Verify guest cart was deleted
      const deletedGuestCart = await Cart.findById(guestCart._id);
      expect(deletedGuestCart).toBeNull();
    });

    it('should merge identical items by adding quantities', async () => {
      // Create user cart with product1
      await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 2, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      // Create guest cart with same product1
      await Cart.create({
        sessionId: guestSessionId,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 3, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const res = await request(app)
        .post('/api/cart/merge')
        .set('Authorization', `Bearer ${token}`)
        .send({ guestSessionId });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(1);
      expect(res.body.data.items[0].quantity).toBe(5); // 2 + 3
    });

    it('should handle merging when user has no existing cart', async () => {
      // Create only guest cart
      await Cart.create({
        sessionId: guestSessionId,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const res = await request(app)
        .post('/api/cart/merge')
        .set('Authorization', `Bearer ${token}`)
        .send({ guestSessionId });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(1);
      expect(res.body.message).toBe('Cart merged successfully');
    });

    it('should handle merging when guest cart is empty', async () => {
      // Create user cart
      const userCart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const res = await request(app)
        .post('/api/cart/merge')
        .set('Authorization', `Bearer ${token}`)
        .send({ guestSessionId: 'non-existent-session' });

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.message).toBe('No guest cart to merge');
    });

    it('should require guest session ID for merge', async () => {
      const res = await request(app)
        .post('/api/cart/merge')
        .set('Authorization', `Bearer ${token}`)
        .send({});

      expect(res.status).toBe(400);
      expect(res.body.success).toBe(false);
      expect(res.body.message).toBe('Guest session ID is required');
    });
  });

  describe('Cart API error handling', () => {
    it('should handle session ID requirement for guest operations', async () => {
      const endpoints = [
        { method: 'post', path: '/api/cart/items', data: { productId: (product1 as IProductDocument)._id.toString(), quantity: 1 } },
        { method: 'put', path: `/api/cart/items/${new mongoose.Types.ObjectId()}`, data: { quantity: 2 } },
        { method: 'delete', path: `/api/cart/items/${new mongoose.Types.ObjectId()}`, data: {} }
      ];

      for (const endpoint of endpoints) {
        const res = await request(app)[endpoint.method](endpoint.path)
          .send(endpoint.data);

        expect(res.status).toBe(400);
        expect(res.body.success).toBe(false);
        expect(res.body.message).toBe('Session ID required for guest cart');
      }
    });

    it('should handle missing product ID', async () => {
      const res = await request(app)
        .post('/api/cart/items')
        .set('Authorization', `Bearer ${token}`)
        .send({ quantity: 1 });

      expect(res.status).toBe(400);
      expect(res.body.success).toBe(false);
      expect(res.body.message).toBe('Product ID is required');
    });

    it('should handle non-existent product', async () => {
      const nonExistentProductId = new mongoose.Types.ObjectId();

      const res = await request(app)
        .post('/api/cart/items')
        .set('Authorization', `Bearer ${token}`)
        .send({ productId: nonExistentProductId.toString(), quantity: 1 });

      expect(res.status).toBe(404);
      expect(res.body.success).toBe(false);
      expect(res.body.message).toBe('Product not found');
    });
  });
});
// Add this describe block after the existing Cart operations tests:

describe('DELETE /api/cart/clear (clearCart)', () => {
  it('should clear all items from authenticated user cart', async () => {
    // Create cart with multiple items following your multi-vendor pattern
    await Cart.create({
      userId: (user as IUserDocument)._id,
      items: [
        { productId: (product1 as IProductDocument)._id, quantity: 2, price: 10, name: 'Product 1', sku: 'P1' },
        { productId: (product2 as IProductDocument)._id, quantity: 1, price: 20, name: 'Product 2', sku: 'P2' }
      ]
    });

    const res = await request(app)
      .delete('/api/cart/clear')
      .set('Authorization', `Bearer ${token}`);

    expect(res.status).toBe(200);
    expect(res.body.success).toBe(true);
    expect(res.body.data.items).toHaveLength(0);
    expect(res.body.data.itemCount).toBe(0);
    expect(res.body.message).toBe('Cart cleared');
  });

  it('should clear guest cart with session ID', async () => {
    // Create guest cart following your session management pattern
    await Cart.create({
      sessionId: guestSessionId,
      items: [
        { productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }
      ]
    });

    const res = await request(app)
      .delete('/api/cart/clear')
      .set('x-session-id', guestSessionId);

    expect(res.status).toBe(200);
    expect(res.body.success).toBe(true);
    expect(res.body.data.items).toHaveLength(0);
    expect(res.body.message).toBe('Cart cleared');
  });

  it('should handle clearing empty cart gracefully', async () => {
    // Test clearing non-existent cart following your AppError pattern
    const res = await request(app)
      .delete('/api/cart/clear')
      .set('Authorization', `Bearer ${token}`);

    expect(res.status).toBe(200);
    expect(res.body.success).toBe(true);
    expect(res.body.message).toBe('Cart is already empty');
  });

  it('should require session ID for guest cart clearing', async () => {
    // Test AppError pattern for missing session ID
    const res = await request(app)
      .delete('/api/cart/clear');

    expect(res.status).toBe(400);
    expect(res.body.success).toBe(false);
    expect(res.body.message).toBe('Session ID required for guest cart');
  });

  it('should handle clearing non-existent guest cart', async () => {
    const nonExistentSessionId = new mongoose.Types.ObjectId().toString();

    const res = await request(app)
      .delete('/api/cart/clear')
      .set('x-session-id', nonExistentSessionId);

    expect(res.status).toBe(200);
    expect(res.body.success).toBe(true);
    expect(res.body.message).toBe('Cart is already empty');
  });

  it('should maintain cart structure after clearing', async () => {
    // Create cart with items following your Mongoose schema patterns
    const originalCart = await Cart.create({
      userId: (user as IUserDocument)._id,
      items: [
        { productId: (product1 as IProductDocument)._id, quantity: 3, price: 10, name: 'Product 1', sku: 'P1' }
      ]
    });

    const res = await request(app)
      .delete('/api/cart/clear')
      .set('Authorization', `Bearer ${token}`);

    expect(res.status).toBe(200);
    expect(res.body.success).toBe(true);
    
    // Verify cart still exists but is empty (following your DocumentArray pattern)
    const clearedCart = await Cart.findById(originalCart._id);
    expect(clearedCart).toBeTruthy();
    expect(clearedCart?.items).toHaveLength(0);
    expect(clearedCart?.userId).toEqual((user as IUserDocument)._id);
  });

  it('should properly clear cart using Mongoose DocumentArray splice method', async () => {
    // Test your DocumentArray clearing fix from cartController line 305
    const cart = await Cart.create({
      userId: (user as IUserDocument)._id,
      items: [
        { productId: (product1 as IProductDocument)._id, quantity: 2, price: 10, name: 'Product 1', sku: 'P1' },
        { productId: (product2 as IProductDocument)._id, quantity: 3, price: 20, name: 'Product 2', sku: 'P2' }
      ]
    });

    const res = await request(app)
      .delete('/api/cart/clear')
      .set('Authorization', `Bearer ${token}`);

    expect(res.status).toBe(200);
    expect(res.body.success).toBe(true);
    
    // Verify the DocumentArray was properly cleared using splice method
    // Helper to generate a valid JWT for a user
    const generateToken = (userId: mongoose.Types.ObjectId): string => {
      return jwt.sign({ id: userId }, process.env.JWT_SECRET as string, { expiresIn: '1h' });
    };

    describe('Cart API - Additional clearCart Tests', () => {
      let user: IUser;
      let token: string;
      let product1: IProduct;
      let product2: IProduct;
      let vendorUser: IUser;
      let vendorToken: string;
      const guestSessionId = new mongoose.Types.ObjectId().toString();

      beforeEach(async () => {
        // Clear collections before each test
        await User.deleteMany({});
        await Product.deleteMany({});
        await Cart.deleteMany({});

        // Create test user
        user = await User.create({
          name: 'Test User',
          email: 'test@example.com',
          password: '123456',
          role: 'user'
        }) as IUserDocument;

        token = generateToken((user as IUserDocument)._id);

        // Create vendor user
        vendorUser = await User.create({
          name: 'Vendor User',
          email: 'vendor@example.com',
          password: '123456',
          role: 'vendor'
        }) as IUserDocument;

        vendorToken = generateToken((vendorUser as IUserDocument)._id);

        // Create test products
        product1 = await Product.create({
          name: 'Product 1',
          description: 'Description 1',
          price: 10,
          category: 'Category 1',
          vendor: (vendorUser as IUserDocument)._id,
          stock: 100
        }) as IProductDocument;

        product2 = await Product.create({
          name: 'Product 2',
          description: 'Description 2',
          price: 20,
          category: 'Category 2',
          vendor: (vendorUser as IUserDocument)._id,
          stock: 50
        }) as IProductDocument;
      });

      describe('DELETE /api/cart/clear - Performance & Load Tests', () => {
        it('should handle clearing cart with large number of items efficiently', async () => {
          // Create cart with many items to test performance
          const manyItems = Array.from({ length: 50 }, (_, index) => ({
            productId: index % 2 === 0 ? (product1 as IProductDocument)._id : (product2 as IProductDocument)._id,
            quantity: Math.floor(Math.random() * 5) + 1,
            price: index % 2 === 0 ? 10 : 20,
            name: `Product ${index % 2 + 1}`,
            sku: `P${index % 2 + 1}`
          }));

          const cart = await Cart.create({
            userId: (user as IUserDocument)._id,
            items: manyItems
          });

          const startTime = Date.now();

          const res = await request(app)
            .delete('/api/cart/clear')
            .set('Authorization', `Bearer ${token}`);

          const endTime = Date.now();
          const executionTime = endTime - startTime;

          expect(res.status).toBe(200);
          expect(res.body.success).toBe(true);
          expect(res.body.data.items).toHaveLength(0);
          expect(res.body.message).toBe('Cart cleared');
          expect(executionTime).toBeLessThan(1000); // Should complete within 1 second

          // Verify database state
          const clearedCart = await Cart.findById(cart._id);
          expect(clearedCart?.items).toHaveLength(0);
        });

        it('should handle multiple rapid clear requests without race conditions', async () => {
          // Create cart with items
          const cart = await Cart.create({
            userId: (user as IUserDocument)._id,
            items: [
              { productId: (product1 as IProductDocument)._id, quantity: 5, price: 10, name: 'Product 1', sku: 'P1' },
              { productId: (product2 as IProductDocument)._id, quantity: 3, price: 20, name: 'Product 2', sku: 'P2' }
            ]
          });

          // Fire multiple requests simultaneously
          const promises = Array.from({ length: 10 }, () =>
            request(app)
              .delete('/api/cart/clear')
              .set('Authorization', `Bearer ${token}`)
          );

          const results = await Promise.all(promises);

          // All requests should succeed
          results.forEach(res => {
            expect(res.status).toBe(200);
            expect(res.body.success).toBe(true);
          });

          // Verify final state
          const finalCart = await Cart.findById(cart._id);
          expect(finalCart?.items).toHaveLength(0);
        });
      });

      describe('DELETE /api/cart/clear - Authentication Edge Cases', () => {
        it('should handle expired JWT token gracefully', async () => {
          // Create cart with items
          await Cart.create({
            userId: (user as IUserDocument)._id,
            items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
          });

          // Create expired token (expired 1 hour ago)
          const expiredToken = jwt.sign(
            { id: (user as IUserDocument)._id },
            process.env.JWT_SECRET as string,
            { expiresIn: '-1h' }
          );

          const res = await request(app)
            .delete('/api/cart/clear')
            .set('Authorization', `Bearer ${expiredToken}`);

          expect(res.status).toBe(401);
          expect(res.body.success).toBe(false);
        });

        it('should handle malformed JWT token', async () => {
          const res = await request(app)
            .delete('/api/cart/clear')
            .set('Authorization', 'Bearer invalid.jwt.token');

          expect(res.status).toBe(401);
          expect(res.body.success).toBe(false);
        });

        it('should handle missing Bearer prefix in Authorization header', async () => {
          const res = await request(app)
            .delete('/api/cart/clear')
            .set('Authorization', token); // Missing "Bearer " prefix

          expect(res.status).toBe(401);
          expect(res.body.success).toBe(false);
        });
      });

      describe('DELETE /api/cart/clear - Data Consistency Tests', () => {
        it('should maintain referential integrity after clearing cart', async () => {
          // Create cart with items
          const cart = await Cart.create({
            userId: (user as IUserDocument)._id,
            items: [
              { productId: (product1 as IProductDocument)._id, quantity: 2, price: 10, name: 'Product 1', sku: 'P1' },
              { productId: (product2 as IProductDocument)._id, quantity: 1, price: 20, name: 'Product 2', sku: 'P2' }
            ]
          });

          const res = await request(app)
            .delete('/api/cart/clear')
            .set('Authorization', `Bearer ${token}`);

          expect(res.status).toBe(200);

          // Verify products still exist
          const existingProduct1 = await Product.findById((product1 as IProductDocument)._id);
          const existingProduct2 = await Product.findById((product2 as IProductDocument)._id);
          expect(existingProduct1).toBeTruthy();
          expect(existingProduct2).toBeTruthy();

          // Verify user still exists
          const existingUser = await User.findById((user as IUserDocument)._id);
          expect(existingUser).toBeTruthy();

          // Verify cart document structure is preserved
          const clearedCart = await Cart.findById(cart._id);
          expect(clearedCart?.userId).toEqual((user as IUserDocument)._id);
          expect(clearedCart?.items).toHaveLength(0);
        });

        it('should handle clearing cart when products are deleted externally', async () => {
          // Create cart with items
          const cart = await Cart.create({
            userId: (user as IUserDocument)._id,
            items: [
              { productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }
            ]
          });

          // Delete the product externally
          await Product.deleteOne({ _id: (product1 as IProductDocument)._id });

          const res = await request(app)
            .delete('/api/cart/clear')
            .set('Authorization', `Bearer ${token}`);

          expect(res.status).toBe(200);
          expect(res.body.success).toBe(true);
          expect(res.body.data.items).toHaveLength(0);
          expect(res.body.message).toBe('Cart cleared');
        });
      });

      describe('DELETE /api/cart/clear - Multi-vendor Scenarios', () => {
        it('should clear cart containing items from multiple vendors', async () => {
          // Create another vendor
          const vendor2 = await User.create({
            name: 'Vendor 2',
            email: 'vendor2@example.com',
            password: '123456',
            role: 'vendor'
          }) as IUserDocument;

          // Create product from second vendor
          const product3 = await Product.create({
            name: 'Product 3',
            description: 'Description 3',
            price: 30,
            category: 'Category 3',
            vendor: vendor2._id,
            stock: 25
          }) as IProductDocument;

          // Create cart with items from multiple vendors
          await Cart.create({
            userId: (user as IUserDocument)._id,
            items: [
              { productId: (product1 as IProductDocument)._id, quantity: 2, price: 10, name: 'Product 1', sku: 'P1' },
              { productId: (product2 as IProductDocument)._id, quantity: 1, price: 20, name: 'Product 2', sku: 'P2' },
              { productId: product3._id, quantity: 3, price: 30, name: 'Product 3', sku: 'P3' }
            ]
          });

          const res = await request(app)
            .delete('/api/cart/clear')
            .set('Authorization', `Bearer ${token}`);

          expect(res.status).toBe(200);
          expect(res.body.success).toBe(true);
          expect(res.body.data.items).toHaveLength(0);
          expect(res.body.data.itemCount).toBe(0);
          expect(res.body.message).toBe('Cart cleared');
        });

        it('should clear vendor cart without affecting customer carts', async () => {
          // Create vendor cart
          const vendorCart = await Cart.create({
            userId: (vendorUser as IUserDocument)._id,
            items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
          });

          // Create customer cart
          const customerCart = await Cart.create({
            userId: (user as IUserDocument)._id,
            items: [{ productId: (product2 as IProductDocument)._id, quantity: 2, price: 20, name: 'Product 2', sku: 'P2' }]
          });

          // Clear vendor cart
          const res = await request(app)
            .delete('/api/cart/clear')
            .set('Authorization', `Bearer ${vendorToken}`);

          expect(res.status).toBe(200);
          expect(res.body.success).toBe(true);

          // Verify vendor cart is cleared
          const clearedVendorCart = await Cart.findById(vendorCart._id);
          expect(clearedVendorCart?.items).toHaveLength(0);

          // Verify customer cart is unchanged
          const unchangedCustomerCart = await Cart.findById(customerCart._id);
          expect(unchangedCustomerCart?.items).toHaveLength(1);
        });
      });

      describe('DELETE /api/cart/clear - Session Management Edge Cases', () => {
        it('should handle clearing guest cart with very long session ID', async () => {
          const longSessionId = 'a'.repeat(100); // Very long session ID

          await Cart.create({
            sessionId: longSessionId,
            items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
          });

          const res = await request(app)
            .delete('/api/cart/clear')
            .set('x-session-id', longSessionId);

          expect(res.status).toBe(200);
          expect(res.body.success).toBe(true);
          expect(res.body.data.items).toHaveLength(0);
        });

        it('should handle session ID with special characters', async () => {
          const specialSessionId = 'session-id_123.test@domain.com';

          await Cart.create({
            sessionId: specialSessionId,
            items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
          });

          const res = await request(app)
            .delete('/api/cart/clear')
            .set('x-session-id', specialSessionId);

          expect(res.status).toBe(200);
          expect(res.body.success).toBe(true);
          expect(res.body.data.items).toHaveLength(0);
        });

        it('should handle clearing multiple guest carts with different session IDs', async () => {
          const sessionId1 = new mongoose.Types.ObjectId().toString();
          const sessionId2 = new mongoose.Types.ObjectId().toString();

          // Create two different guest carts
          const cart1 = await Cart.create({
            sessionId: sessionId1,
            items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
          });

          const cart2 = await Cart.create({
            sessionId: sessionId2,
            items: [{ productId: (product2 as IProductDocument)._id, quantity: 2, price: 20, name: 'Product 2', sku: 'P2' }]
          });

          // Clear first cart
          const res1 = await request(app)
            .delete('/api/cart/clear')
            .set('x-session-id', sessionId1);

          expect(res1.status).toBe(200);
          expect(res1.body.success).toBe(true);

          // Verify first cart is cleared
          const clearedCart1 = await Cart.findById(cart1._id);
          expect(clearedCart1?.items).toHaveLength(0);

          // Verify second cart is unchanged
          const unchangedCart2 = await Cart.findById(cart2._id);
          expect(unchangedCart2?.items).toHaveLength(1);

          // Clear second cart
          const res2 = await request(app)
            .delete('/api/cart/clear')
            .set('x-session-id', sessionId2);

          expect(res2.status).toBe(200);
          expect(res2.body.success).toBe(true);

          // Verify second cart is now cleared
          const clearedCart2 = await Cart.findById(cart2._id);
          expect(clearedCart2?.items).toHaveLength(0);
        });
      });

      describe('DELETE /api/cart/clear - Response Structure Validation', () => {
        it('should return consistent response structure for all clear scenarios', async () => {
          // Test with existing cart
          await Cart.create({
            userId: (user as IUserDocument)._id,
            items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
          });

          const res1 = await request(app)
            .delete('/api/cart/clear')
            .set('Authorization', `Bearer ${token}`);

          expect(res1.status).toBe(200);
          expect(res1.body).toHaveProperty('success', true);
          expect(res1.body).toHaveProperty('data');
          expect(res1.body.data).toHaveProperty('items');
          expect(res1.body.data).toHaveProperty('itemCount', 0);
          expect(res1.body).toHaveProperty('message', 'Cart cleared');

          // Test with non-existent cart
          const res2 = await request(app)
            .delete('/api/cart/clear')
            .set('Authorization', `Bearer ${token}`);

          expect(res2.status).toBe(200);
          expect(res2.body).toHaveProperty('success', true);
          expect(res2.body).toHaveProperty('message', 'Cart is already empty');
        });

        it('should return appropriate error response for invalid requests', async () => {
          // Test without authentication or session ID
          const res = await request(app)
            .delete('/api/cart/clear');

          expect(res.status).toBe(400);
          expect(res.body).toHaveProperty('success', false);
          expect(res.body).toHaveProperty('message', 'Session ID required for guest cart');
        });
      });

      describe('DELETE /api/cart/clear - Database Transaction Safety', () => {
        it('should handle cart clearing during concurrent database operations', async () => {
          // Create cart with items
          const cart = await Cart.create({
            userId: (user as IUserDocument)._id,
            items: [
              { productId: (product1 as IProductDocument)._id, quantity: 5, price: 10, name: 'Product 1', sku: 'P1' },
              { productId: (product2 as IProductDocument)._id, quantity: 3, price: 20, name: 'Product 2', sku: 'P2' }
            ]
          });

          // Simulate concurrent operations
          const clearPromise = request(app)
            .delete('/api/cart/clear')
            .set('Authorization', `Bearer ${token}`);

          const updatePromise = Cart.findByIdAndUpdate(cart._id, {
            $push: { items: { productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' } }
          });

          const [clearResult] = await Promise.all([clearPromise, updatePromise]);

          expect(clearResult.status).toBe(200);
          expect(clearResult.body.success).toBe(true);

          // Verify final state is consistent
          const finalCart = await Cart.findById(cart._id);
          expect(finalCart?.items).toHaveLength(0);
        });
      });
    });

      // Both should succeed (idempotent operation)
      results.forEach(res => {
        expect(res.status).toBe(200);
        expect(res.body.success).toBe(true);
      });

      // Verify cart is actually cleared
      const finalCart = await Cart.findById(cart._id);
      expect(finalCart?.items).toHaveLength(0);
    });

    it('should handle clearing cart with invalid session header format', async () => {
      // Test your session ID validation pattern
      const res = await request(app)
        .delete('/api/cart')
        .set('x-session-id', ''); // Empty session ID

      expect(res.status).toBe(400);
      expect(res.body.success).toBe(false);
      expect(res.body.message).toBe('Session ID required for guest cart');
    });

    it('should preserve cart metadata after clearing', async () => {
      // Test your cart structure preservation pattern
      const originalCart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [
          { productId: (product1 as IProductDocument)._id, quantity: 5, price: 10, name: 'Product 1', sku: 'P1' }
        ]
      });

      const res = await request(app)
        .delete('/api/cart')
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);

      // Verify cart document still exists with proper structure
      const clearedCart = await Cart.findById(originalCart._id);
      expect(clearedCart).toBeTruthy();
      expect(clearedCart?.userId).toEqual((user as IUserDocument)._id);
      expect(clearedCart?.createdAt).toBeDefined();
      expect(clearedCart?.updatedAt).toBeDefined();
      expect(Array.isArray(clearedCart?.items)).toBe(true);
    });

    it('should handle clearing cart with archived products', async () => {
      // Create archived product following your product management pattern
      const archivedProduct = await Product.create({
        name: 'Archived Product',
        description: 'This product was archived',
        price: 25,
        category: 'Archive Category',
        vendor: (user as IUserDocument)._id,
        stock: 0,
        isArchived: true
      });

      await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [
          { productId: archivedProduct._id, quantity: 1, price: 25, name: 'Archived Product', sku: 'ARCH1' }
        ]
      });

      const res = await request(app)
        .delete('/api/cart')
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(0);
      expect(res.body.message).toBe('Cart cleared');
    });

    it('should handle clearing guest cart with malformed session ID', async () => {
      // Test your session validation following AppError pattern
      const malformedSessionIds = ['invalid-session', '123', 'not-mongoose-id'];

      for (const sessionId of malformedSessionIds) {
        const res = await request(app)
          .delete('/api/cart')
          .set('x-session-id', sessionId);

        expect(res.status).toBe(200);
        expect(res.body.success).toBe(true);
        expect(res.body.message).toBe('Cart is already empty');
      }
    });

    it('should verify DocumentArray splice implementation', async () => {
      // Test your specific fix for Mongoose DocumentArray clearing (line 305)
      const cart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [
          { productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' },
          { productId: (product2 as IProductDocument)._id, quantity: 2, price: 20, name: 'Product 2', sku: 'P2' }
        ]
      });

      // Verify initial state
      expect(cart.items).toHaveLength(2);
      
      const res = await request(app)
        .delete('/api/cart')
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(200);
      
      // Verify the splice operation worked correctly
      const updatedCart = await Cart.findById(cart._id);
      expect(updatedCart?.items).toHaveLength(0);
      expect(updatedCart?.items.isModified).toBeDefined(); // Mongoose DocumentArray method
    });

    it('should handle clearing cart with product variants', async () => {
      // Test clearing cart with your variant management pattern
      const productWithVariants = await Product.create({
        name: 'Variable Product',
        description: 'Product with variants',
        price: 30,
        category: 'Variable Category',
        vendor: (user as IUserDocument)._id,
        stock: 100,
        variants: [
          { _id: new mongoose.Types.ObjectId(), value: 'Size S', price: 30, sku: 'VAR-S', stock: 25 },
          { _id: new mongoose.Types.ObjectId(), value: 'Size M', price: 35, sku: 'VAR-M', stock: 40 }
        ]
      });

      await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [
          { 
            productId: productWithVariants._id, 
            variantId: productWithVariants.variants[0]._id,
            quantity: 2, 
            price: 30, 
            name: 'Variable Product - Size S', 
            sku: 'VAR-S' 
          }
        ]
      });

      const res = await request(app)
        .delete('/api/cart')
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.data.items).toHaveLength(0);
    });

    it('should maintain proper response structure for both user types', async () => {
      // Test authenticated user cart clearing response structure
      await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      const userRes = await request(app)
        .delete('/api/cart')
        .set('Authorization', `Bearer ${token}`);

      expect(userRes.status).toBe(200);
      expect(userRes.body).toHaveProperty('success', true);
      expect(userRes.body).toHaveProperty('data');
      expect(userRes.body.data).toHaveProperty('itemCount', 0);
      expect(userRes.body).toHaveProperty('message', 'Cart cleared');

      // Test guest cart clearing response structure
      await Cart.create({
        sessionId: guestSessionId,
        items: [{ productId: (product2 as IProductDocument)._id, quantity: 1, price: 20, name: 'Product 2', sku: 'P2' }]
      });

      const guestRes = await request(app)
        .delete('/api/cart')
        .set('x-session-id', guestSessionId);

      expect(guestRes.status).toBe(200);
      expect(guestRes.body).toHaveProperty('success', true);
      expect(guestRes.body).toHaveProperty('data');
      expect(guestRes.body.data).toHaveProperty('itemCount', 0);
      expect(guestRes.body).toHaveProperty('message', 'Cart cleared');
    });

    it('should handle database errors gracefully during clear operation', async () => {
      // Create cart
      const cart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [{ productId: (product1 as IProductDocument)._id, quantity: 1, price: 10, name: 'Product 1', sku: 'P1' }]
      });

      // Mock database error by removing the cart mid-operation
      await Cart.deleteOne({ _id: cart._id });

      const res = await request(app)
        .delete('/api/cart')
        .set('Authorization', `Bearer ${token}`);

      // Should handle gracefully (cart not found = already empty)
      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
      expect(res.body.message).toBe('Cart is already empty');
    });

    it('should verify cart cleared event following your event pattern', async () => {
      // Test that cart clearing follows your business logic patterns
      const initialItemCount = 5;
      const cart = await Cart.create({
        userId: (user as IUserDocument)._id,
        items: [
          { productId: (product1 as IProductDocument)._id, quantity: 3, price: 10, name: 'Product 1', sku: 'P1' },
          { productId: (product2 as IProductDocument)._id, quantity: 2, price: 20, name: 'Product 2', sku: 'P2' }
        ]
      });

      // Verify initial count
      const preCount = cart.items.reduce((total, item) => total + item.quantity, 0);
      expect(preCount).toBe(initialItemCount);

      const res = await request(app)
        .delete('/api/cart')
        .set('Authorization', `Bearer ${token}`);

      expect(res.status).toBe(200);
      expect(res.body.data.itemCount).toBe(0);
      
      // Verify final count matches response
      const finalCart = await Cart.findById(cart._id);
      const finalCount = finalCart?.items.reduce((total, item) => total + item.quantity, 0) || 0;
      expect(finalCount).toBe(0);
    });
  });
});
